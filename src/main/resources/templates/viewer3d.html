<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Viewer</title>
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
    <style>
        html, body { height: 100%; margin: 0; }
        #plot { width: 100%; height: 100%; }
    </style>
</head>
<body>
<div id="plot"></div>
<script>
(async function () {
  try {
    const params = new URLSearchParams(location.search);
    const layerParam = params.get('layers');
    const overlap = params.get('overlap') === '1';
    const primary = params.get('primary'); // 개별 모드에서 주 레이어
    const compsParam = (params.get('comps')||'');
    const selectedComps = compsParam ? compsParam.split(',').filter(Boolean) : [];
    const res = await fetch('/api/get-output-json');
    const json = await res.json();
    if (!json.success) throw new Error(json.message || 'failed to load output.json');
    const data = json.data || {};
    const addresses = (data.addresses || []);
    const lines = (data.lines || []);
    const stations = (data.stations || []);

    function colorByZ(z) {
      if (z === 6022.0) return '#ff4444';
      if (z === 4822.0) return '#4444ff';
      if (z === 0.0) return '#ffff44';
      return '#888888';
    }

    // Lines merged trace per style
    const groups = {};
    function styleFor(z1, z2) {
      // 교차 레이어 라인은 검정색, 굵기 3으로 강조
      if (Math.abs(z1 - z2) > 1e-6) return ['#000000', 3];
      if (z1===6022.0 && z2===6022.0) return ['#ff4444', 1];
      if (z1===4822.0 && z2===4822.0) return ['#4444ff', 1];
      if (z1===0.0    && z2===0.0)    return ['#ffff44', 1];
      return ['#44ff44', 1];
    }
    const selectedLayers = (layerParam ? layerParam.split(',') : []);
    const zOf = { z6022: 6022.0, z4822: 4822.0, z0: 0.0 };
    function layerMatches(pos){
      if (!selectedLayers.length) return true;
      const z = pos && typeof pos.z==='number' ? pos.z : undefined;
      const needed = selectedLayers.map(l=>zOf[l]).filter(v=>typeof v==='number');
      return needed.includes(z);
    }

    for (const l of lines) {
      if (!l.fromPos || !l.toPos) continue;
      if (!overlap) {
        // 개별 모드: 해당 창의 primary 레이어와 다른 레이어를 잇는 교차선은 표시
        // 단, 둘 다 선택된 레이어 집합 외면 제외
        const bothInSelected = (!selectedLayers.length) || (layerMatches(l.fromPos) && layerMatches(l.toPos));
        if (!bothInSelected) continue;
        if (primary) {
          const zOf = { z6022: 6022.0, z4822: 4822.0, z0: 0.0 };
          const pz = zOf[primary];
          const hasPrimary = Math.abs(l.fromPos.z - pz) < 1e-6 || Math.abs(l.toPos.z - pz) < 1e-6;
          if (!hasPrimary) continue;
        } else {
          if (!layerMatches(l.fromPos) || !layerMatches(l.toPos)) continue;
        }
      } else {
        // overlap 모드: 선택된 레이어 집합 안에서만 표시 (교차선 포함)
        if (selectedLayers.length && !(layerMatches(l.fromPos) && layerMatches(l.toPos))) continue;
      }
      const z1 = l.fromPos.z, z2 = l.toPos.z;
      const key = styleFor(z1,z2).join('_');
      if (!groups[key]) groups[key] = {x:[],y:[],z:[],style:styleFor(z1,z2)};
      groups[key].x.push(l.fromPos.x, l.toPos.x, null);
      groups[key].y.push(l.fromPos.y, l.toPos.y, null);
      groups[key].z.push(l.fromPos.z, l.toPos.z, null);
    }

    const traces = [];
    for (const k in groups) {
      const g = groups[k];
      if (!selectedComps.length || selectedComps.includes('lines')) {
        traces.push({
          type: 'scatter3d', mode: 'lines', x: g.x, y: g.y, z: g.z,
          line: { color: g.style[0], width: g.style[1] }, hoverinfo: 'skip', name: 'lines'
        });
      }
    }

    // Addresses
    const ax = [], ay = [], az = [], acolor = [], atext=[];
    for (const a of addresses) {
      if (!a.pos) continue;
      if (selectedLayers.length && !layerMatches(a.pos)) continue;
      ax.push(a.pos.x); ay.push(a.pos.y); az.push(a.pos.z); acolor.push(colorByZ(a.pos.z)); atext.push(String(a.id));
    }
    if (!selectedComps.length || selectedComps.includes('addresses')) {
      traces.push({ type: 'scatter3d', mode: 'markers', x: ax, y: ay, z: az, marker: { size: 1, color: acolor, opacity: 0.8 }, text: atext, name:'addresses' });
    }

    // Stations
    if (stations && stations.length && (!selectedComps.length || selectedComps.includes('stations'))) {
      const sx=[], sy=[], sz=[], stext=[];
      for (const s of stations) { if (!s.pos) continue; if (selectedLayers.length && !layerMatches(s.pos)) continue; sx.push(s.pos.x); sy.push(s.pos.y); sz.push(s.pos.z); stext.push(String(s.id)); }
      traces.push({ type:'scatter3d', mode:'markers', x:sx, y:sy, z:sz, marker:{ size:2, color:'#FFD700', symbol:'diamond', opacity:0.9 }, text: stext, name:'stations' });
    }

    // OHTs animation (if selected) - OHT_ID 별로 분리
    if (!selectedComps.length || selectedComps.includes('ohts')) {
      try {
        const logRes = await fetch('/api/get-udp-log');
        const logJson = await logRes.json();
        if (logJson.success && Array.isArray(logJson.lines) && logJson.lines.length) {
          const squareTime = /^\s*\[([^\]]+)\]/;
          const currZeroNext = /,\s*(\d{5,})\s*,\s*0\s*,\s*\d{5,}\s*,/;
          const mcpOht = /Message\s*=\s*\d+\s*,\s*(OHT\d+)\s*,/i; // "Message=2,OHT1,"
          const legacyTime = /Time\s*:\s*([^,]+)/;
          const legacyCurr = /Current Address\s*:\s*(\d+)/;
          const entries = [];
          for (const line of logJson.lines) {
            let timeStr = null, currAddr = null, m;
            if ((m = squareTime.exec(line))) timeStr = m[1].trim();
            if ((m = currZeroNext.exec(line))) currAddr = parseInt(m[1]);
            let ohtTag = null; if ((m = mcpOht.exec(line))) ohtTag = m[1].toUpperCase();
            if (!timeStr && (m = legacyTime.exec(line))) timeStr = m[1].trim();
            if (currAddr == null && (m = legacyCurr.exec(line))) currAddr = parseInt(m[1]);
            if (timeStr && currAddr != null && ohtTag) entries.push([timeStr, currAddr, ohtTag]);
          }
          const addrMap = new Map();
          for (const a of addresses) { if (a && a.address != null && a.pos) addrMap.set(parseInt(a.address), [a.pos.x, a.pos.y, a.pos.z]); }
          // OHT별 그룹화
          const ohtToPos = new Map();
          for (const [_, code, tag] of entries) {
            const p = addrMap.get(code); if (!p) continue;
            if (selectedLayers.length && !layerMatches({z:p[2]})) continue;
            if (!ohtToPos.has(tag)) ohtToPos.set(tag, []);
            ohtToPos.get(tag).push(p);
          }
          const colors = ['#00FFFF', '#00FF7F', '#FF00FF', '#FFA500', '#00BFFF', '#ADFF2F', '#FF69B4', '#8A2BE2', '#FF4500', '#2E8B57'];
          let colorIdx = 0;
          const ohtTraceIndices = [];
          const ohtPaths = [];
          for (const [tag, plist] of ohtToPos.entries()) {
            if (!plist.length) continue;
            const MAX = 1500; let pos = plist; if (pos.length > MAX) { const step = Math.ceil(pos.length / MAX); pos = pos.filter((_,i)=> i%step===0); }
            const x=[pos[0][0]], y=[pos[0][1]], z=[pos[0][2]];
            const color = colors[colorIdx++ % colors.length];
            traces.push({ type:'scatter3d', mode:'markers', x, y, z, marker:{ size:4, color:color }, name: tag });
            ohtTraceIndices.push(traces.length - 1);
            ohtPaths.push(pos);
          }
          if (ohtTraceIndices.length) {
            let frame = 0; const intervalMs = 100;
            function tick(){
              const xs=[], ys=[], zs=[];
              for (let t=0; t<ohtTraceIndices.length; t++) {
                const pos = ohtPaths[t]; const p = pos[frame % pos.length];
                xs.push([p[0]]); ys.push([p[1]]); zs.push([p[2]]);
              }
              Plotly.restyle('plot', { x: xs, y: ys, z: zs }, ohtTraceIndices);
              frame++; setTimeout(()=>requestAnimationFrame(tick), intervalMs);
            }
            requestAnimationFrame(tick);
          }
        }
      } catch(e) { /* ignore */ }
    }

    const layout = {
      title: '3D Layout Viewer',
      scene: {
        xaxis:{title:'X', showgrid:true, gridcolor:'lightgray'},
        yaxis:{title:'Y', showgrid:true, gridcolor:'lightgray'},
        zaxis:{title:'Z', showgrid:true, gridcolor:'lightgray'},
        aspectmode: 'data'
      },
      paper_bgcolor:'white', plot_bgcolor:'white'
    };
    Plotly.newPlot('plot', traces, layout, {responsive: true});
  } catch (e) {
    document.getElementById('plot').innerHTML = '<p style="padding:16px">오류: ' + (e.message || e) + '</p>';
  }
})();
</script>
</body>
</html>


